---
title: "EuroBioC2020: Seamless Integration of Mass Spectrometry Data from Different Sources with the `Spectra` Package"
author: "Johannes Rainer^[Institute for Biomedicine, Eurac Research, Bolzano, Italy; johannes.rainer@eurac.edu], Michael Witting^[Research Unit Analytical BioGeoChemistry, Helmholtz Zentrum MÃ¼nchen and Chair of Analytical Food Chemistry, TUM School or Life Sciences, Technical University of Munich, Germany], Sebastian Gibb^[Department of Anaesthesiology and Intensive Care, University Medicine Greifswald, Germany], Laurent Gatto^[Computational Biology Unit, de Duve Institute, UCLouvain, Brussels, Belgium]"
output:
  rmarkdown::html_document:
    highlight: pygments
    toc: true
    toc_depth: 3
    fig_width: 5
vignette: >
  %\VignetteIndexEntry{Seamless Integration of Mass Spectrometry Data from Different Sources; bullet points}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding[utf8]{inputenc}
  %\VignettePackage{SpectraTutorials}
  %\VignetteDepends{Spectra,mzR,RMariaDB,pheatmap,BiocStyle}
bibliography: references.bib
---

```{r style, echo = FALSE, results = 'asis', message = FALSE}
library(BiocStyle)
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

**Last modified:** `r file.info("EuroBioc2020-Spectra-backends.Rmd")$mtime`<br />
**Compiled**: `r date()`

Note: this document is used for the online workshop. A version with more
descriptive text is available
[here](analyzing-MS-data-from-different-sources-with-Spectra.Rmd).


# Introduction

- Describe the concept of *backends* to store/represent mass spectrometry (MS)
  data in the `Spectra` package.
- Use case: match experimental MS2 spectra against *reference* spectra from a
  public spectra database:
    - import MS data from *mzML* files
    - perform some data manipulations on this data
    - match spectra against the [MassBank](https://massbank.eu/MassBank/)
    - export spectra in *MGF* format.



# LC-MS/MS in a nutshell


![LC-MS setup](LC-MS-drawing.gif)

- Mass spectrometry (MS) instruments measure mass-to-charge ratios (m/z) of
  ions.
- Most compounds are not charged, they need to be ionized first (with
  e.g. electro spray ionization (ESI).
- MS is usually combined with another separation technique, such as liquid
  chromatography (LC). This adds another dimension: retention time (rt).
- With LC-MS we measure *features* characterized by m/z and retention time - we
  still don't know what molecule was actually measured.


- Create in addition fragment (MS/MS) spectra from the ions to get some
  information about their structure.

![CID-based fragmentation](MSMS.png)

- Commonly used method: collision induced dissociation (CID). In a collision
  chamber filled with e.g. N2, ions get fragmented, a spectrum of these
  fragments is recorded.
- Matching fragment spectra from an ion against a *reference* helps identifying
  the compound.



# Analysing MS data with `Spectra`

- The `Spectra` package implements a clear separation of user functionality from
  code to provide, store and read mass spectrometry data.

- This represents an extension to the *in-memory* and *on-disk* data modes
  already in the `r Biocpkg("MSnbase")` [@gattoMSnbaseEfficientElegant2020a].

![Spectra: separation into user functionality and data
representation](Spectra.png)

- Enables analysis of very large MS data sets: backends that import the data
  only on demand.

- Below we import the MS data from mzML files containing MSn data of a mix of 8
  standard compounds.

- MS2 data was generated by data dependent acquisition using two different
  collision energies.

- We use the `MsBackendMzR` backend which supports data import from most common
  *raw* MS file formats:

```{r data-import}
library(Spectra)
fls <- dir(system.file("mzML", package = "SpectraTutorials"),
           full.names = TRUE)
sps_all <- Spectra(fls, backend = MsBackendMzR())
```

- `sps_all` is now a `Spectra` object: `data.frame`-like representation with
  columns being spectra variables and rows individual spectra.

- Spectra variables can be accessed *via* `$` or using the dedicates access
  function (preferred way).

- Use `spectraVariables` to list all available spectra variables:

```{r spectraVariables}
spectraVariables(sps_all)
```

- Access retention times of the first spectra:

```{r rtime}
head(sps_all$rtime)
head(rtime(sps_all))
```

- Our `Spectra` object uses a `MsBackendMzR` backend to provide the data.

- Only general spectra information is kept in memory, MS peak data is retrieved
  on demand from the original data files. This ensures a small memory footprint.

```{r on-disk-size}
print(object.size(sps_all), units = "MB")
```

- `MsBackendDataFrame` backend keeps all data in memory.

- `setBackend` allows to change backends - which does not affect the way we can
  use/work with the data.

```{r change-backend}
sps_all <- setBackend(sps_all, MsBackendDataFrame())
print(object.size(sps_all), units = "MB")
```

- Next we subset our data to MS2 spectra with a precursor ion that matches the
  m/z of the [M+H]+ ion of the metabolite Cystine.

```{r filter-precursor-mz}
mz <- 241.0311

sps <- filterPrecursorMz(sps_all, mz = mz + ppm(c(-mz, mz), 10))
sps
```

- In total `r length(sps)` spectra matched our target precursor m/z.


## Data processing and manipulation


- The `plotSpectra` function can be used to visualize spectra.

```{r raw-ms2, fig.width = 7, fig.height = 7}
plotSpectra(sps[1])
```

- Many very low abundance peaks present (noise?).

- Filter the spectra removing all peaks with intensity below 5% of maximum peak.

- Filter function: takes intensity values from each spectrum and returns
  `logical` whether a peak should be kept or not.

- Use `filterIntensity` to apply this function to the data.

```{r filter-intensity, fig.width = 7, fig.height = 7}
low_int <- function(x, ...) {
    x > max(x, na.rm = TRUE) * 0.05
}
sps <- filterIntensity(sps, intensity = low_int)

plotSpectra(sps[1])
```

- Low intensity peaks removed.

- Next: *normalize* each spectrum to get intensities relative to the maximum
  peak intensity (set to a value of `100`).

- Define a function that takes the peak matrix, normalizes the intensities and
  returns the modifier peak matrix.

- Use `addProcessing` to apply the normalization. `addProcessing` can be used to
  apply any user provided function to the peak matrices.

```{r normalize}
norm_int <- function(x, ...) {
    maxint <- max(x[, "intensity"], na.rm = TRUE)
    x[, "intensity"] <- 100 * x[, "intensity"] / maxint
    x
}
sps <- addProcessing(sps, norm_int)
```

- Get the normalized intensities of the first spectrum:

```{r}
intensity(sps)[[1]]
```

- **Note**: data manipulation operations are **not** applied to the actual MS
  data, but cached in the *lazy evaluation queue* of the `Spectra` object.

- Data manipulation are applied *on-the-fly* each time m/z or intensity values
  are accessed. This enables the use of *read-only* data representations
  (e.g. raw data files, databases, ...).

- This mechanism enables us also to *undo* cached data manipulations with the
  `reset` function:

```{r reset}
sps_orig <- reset(sps)
head(intensity(sps_orig)[[1]])
```


## Spectrum data comparison


- Next we perform a pairwise comparison of the spectra.

- Spectra comparison involves:
  - matching of peaks from the compared spectra
  - similarity calculation based on intensities of the matched peaks.

- With `ppm = 20` peaks with a difference in m/z smaller than 20ppm are
  considered matching.

```{r compare-spectra-self}
cormat <- compareSpectra(sps, ppm = 20)
```

- `compareSpectra` allows to specify a mapping function with `MAPFUN` (defaults
  to `joinPeaks` and a similarity calculation function with `FUN` (defaults to
  `ndotproduct`).

- The pairwise spectra similarities are represented with the heatmap below.

```{r ms2-heatmap, fig.width = 7, fig.height = 7}
library(pheatmap)
hm <- pheatmap(cormat, cutree_rows = 3)
```

- The 11 spectra group into 3 clusters related to the collision energy used for
  the fragmentation.

- We reduce our dataset to the cluster with the spectra generated with a
  collision energy of 20eV.

```{r}
split(basename(dataOrigin(sps)), cutree(hm$tree_row, 3))
sps_ce20 <- split(sps, cutree(hm$tree_row, 3))[[1L]]
```


### Matching against MassBank

- Although the precursor m/z matches the m/z of Cystine, we can not exclude that
  they might not be from another ion/compound.

- First step of annotation process: matching experimental spectra against public
  (or in-house) spectral library.

- Many public spectral libraries for small molecules exist:
  - [MassBank](https://massbank.eu/MassBank/)
  - MassBank of North America [MoNa](https://mona.fiehnlab.ucdavis.edu/)
  - Human Metabolom Database [HMDB](https://hmdb.ca/)
  - [GNPS](https://gnps.ucsd.edu/ProteoSAFe/static/gnps-splash.jsp)
  - ...

- Data access to these resources is not standardized.

- [`MsBackendMassbank`](https://github.com/michaelwitting/MsBackendMassbank)
  package: `Spectra` backends for MassBank data:
  - `MsBackendMassbank`: data import/export from/to files in MassBank format.
  - `MsBackendMassbankSql`: direct access to MassBank database.

- Below we load the `MsBackendMassbank` package and connect to a local
  installation of the MassBank MySQL database (release *2020.11*, provided
  within the docker image).

```{r massbank-library}
library(RMariaDB)
library(MsBackendMassbank)

con <- dbConnect(MariaDB(), user = "massbank", dbname = "MassBank",
                 host = "localhost")
```

- Create a `Spectra` object with a `MsBackendMassbankSql` backend to access all
  the data in MassBank.

```{r massbank}
mbank <- Spectra(con, source = MsBackendMassbankSql())
mbank
```

- `mbank` does only contain the primary keys of spectra from the database,
  memory size is thus (relatively) small.

```{r massbank-size}
print(object.size(mbank), units = "MB")
```

- Any operation on this `Spectra` object will load the requested data from the
  database on-the-fly.

- Before matching we subset `mbank` to spectra with a peak matching the
  precursor m/z.

```{r massbank-contains-mz}
has_mz <- containsMz(mbank, mz = mz, ppm = 20)
```

- Note that, to improve performance, we could also load all the spectra data into
  memory by changing the backend with `setBackend` to a
  `MsBackendDataFrame`.

- Calculate spectral similarity between experimental spectra and the
  `r sum(has_mz)` spectra from MassBank.

```{r massbank-compare-subset}
mbank_with_mz <- mbank[has_mz]
res <- compareSpectra(sps_ce20, mbank_with_mz, ppm = 20)
max(res)
```

- Below we indentify the best matching spectrum and access its intensity values.

```{r massbank-intensity}
idx <- which(res == max(res), arr.ind = TRUE)
intensity(mbank_with_mz[idx[2]])
```

- MassBank reports absolute intensities, for better visualization we need to
  *normalize* them the same way we did with our data.

- We can not change the data in MassBank, but `Spectra`'s *lazy evaluation
  queue* allows us to apply data manipulations.

```{r massbank-normalize}
mbank_with_mz <- addProcessing(mbank_with_mz, norm_int)
```

- Compare the best matching spectra with a *mirror plot*.

```{r massbank-mirror-plot, fig.width = 7, fig.height = 7}
## Specifying a function to draw peak labels
label_fun <- function(x) {
    format(unlist(mz(x)), digits = 4)
}
plotSpectraMirror(sps_ce20[idx[1]], mbank_with_mz[idx[2]], tolerance = 0.2,
                  labels = label_fun, labelPos = 2, labelOffset = 0.2,
                  labelSrt = -30)
grid()
```

- Nice match between experimental and *reference* spectrum.

- Next we want to know from which compound the *reference* spectrum was created.

```{r massbank-spectra-variables}
spectraVariables(mbank_with_mz)
```

- Various information on spectra available, but not on the actual compound.

- `MsBackendMassbank` provides method `compounds` that allows to retrieve
  compound annotations from a MassBank database.

- Subset the MassBank `Spectra` to the best matching spectrum and retrieve
  annotation.

```{r massbank-one-spectrum}
mbank_best_match <- mbank_with_mz[idx[2]]
mbank_cmpd <- compounds(mbank_best_match)
mbank_cmpd
```

- Best matching spectrum is in fact a MS2 spectrum of Cystine.

- Add additional annotations to the experimental spectra (name, chemical formula
  and collision energy).

```{r}
sps_ce20$hmdb_id <- mbank_cmpd$name
sps_ce20$formula <- mbank_cmpd$formula
sps_ce20$adduct <- mbank_best_match$adduct
sps_ce20$collisionEnergy <- 20
```

- Note: adding additional annotations should be possible regardless of the used
  backend.


## Data export

- At last we want to export our spectra to a file in MGF format.

- [`MsBackendMgf`](https://github.com/RforMassSpectrometry/MsBackendMgf)
  package: adds support for MGF file import/export.

- Export the data with the `export` function, define the output format with the
`backend` parameter.

```{r export}
library(MsBackendMgf)
export(sps_ce20, backend = MsBackendMgf(), file = "Cystine_ce20.mgf")
```


## Matching against HMDB

In addition to the `MsBackendMassbank`, which provides access to MassBank data,
there is also the
[`MsBackendHmdb`](https://github.com/RforMassSpectrometry/MsBackendHmdb) package
supporting spectral data from the public Human Metabolome Database (HMDB). This
package does however not yet provide direct access to the HMDB database but,
through the `MsBackendHmdbXml` backend, allows to import MS2 spectra files in
HMDB format. These are provided by HMDB as individual xml files in a custom file
format which are bundled (and can hence be downloaded) in a single archive.

To reproduce the following code it is expected (as detailed in the Installation
section) that all xml files from HMDB are available in a folder
*data/hmdb_all_spectra*. Below we identify all xml files containing the key word
`"ms_ms"` in their file name and load them into a `Spectra` object using the
`MsBackendHmdbXml` backend. Note that this import operation from the ~ 500,000
individual xml files takes up to ~ 2 hours to finish.

```{r hmdb-import, eval = FALSE}
library(MsBackendHmdb)
fls <- dir("data/hmdb_all_spectra/", full.names = TRUE, pattern = "ms_ms")
hmdb <- Spectra(fls, source = MsBackendHmdbXml(), nonStop = TRUE)
```

```{r hmdb-import-save, eval = FALSE, echo = FALSE}
## Eventually save for faster re-use
save(hmdb, file = "data/hmdb.RData", compress = "xz")
```

```{r hmdb-load, echo = FALSE}
## Load the pre-generated Spectra object with spectra from HMDB.
library(MsBackendHmdb)
data("hmdb", package = "SpectraTutorials")
```

With this we have now a `Spectra` object containing all MS2 spectra from
HMDB. Note that with the `MsBackendHmdbXml` all spectra data is kept in memory.

```{r}
hmdb
```

Also here, to avoid comparing our experimental spectra against all these
~500,000 spectra, we first determine with the `containsMz` function which of the
HMDB spectra contain a peak matching the m/z of our ion of interest. We have to
use a rather large `tolerance` value (which defines the maximal acceptable
absolute difference in m/z values) since some of the experimental spectra in
HMDB seem to be recorded by not well calibrated instruments.

```{r has-mz}
has_mz <- containsMz(hmdb, mz = mz, tolerance = 0.2)
```

In total `r sum(has_mz)` spectra contain a peak with the required m/z (+/- 0.2
Dalton) and we can proceed to calculate spectral similarities between our
experimental spectra and this subset from HMDB.

```{r compare-subset}
hmdb_with_mz <- hmdb[has_mz]
res <- compareSpectra(sps_ce20, hmdb_with_mz, tolerance = 0.2)
```

The highest similarity between our spectra and the spectra from HMDB is `r
max(res)`. Below we compare the two best matching spectra with a *mirror plot*,
in the upper panel showing our experimental spectrum and in the lower panel the
best matching MS2 spectrum from HMDB.

```{r mirror-plot, fig.width = 7, fig.height = 7}
idx <- which(res == max(res), arr.ind = TRUE)
## Specifying a function to draw peak labels
label_fun <- function(x) {
    format(unlist(mz(x)), digits = 4)
}
plotSpectraMirror(sps_ce20[idx[1]], hmdb_with_mz[idx[2]], tolerance = 0.2,
                  labels = label_fun, labelPos = 2, labelOffset = 0.2,
                  labelSrt = -30)
grid()
```

Our experimental spectrum seems to nicely match the *reference* MS2 in
HMDB. Below we extract the compound identifier from the best matching HMDB
spectrum (stored in a spectra variable called `"compound_id"`)

```{r}
hmdb_with_mz[idx[2]]$compound_id
```

In fact, the matching spectrum from HMDB is an experimental spectrum for
[L-Cystine](https://hmdb.ca/metabolites/HMDB0000192).


# Summary

- Separation of user functionaltity from data storage: ensures flexibility and
  expandability of the `Spectra` package.

- Different backends for different data sources or to enable analysis of very
  large data sets.

- *Lazy evaluation queue* allows to perform data manipulations without changing
  the actual data.

- User functionality is indepenend of the backend.


# References
