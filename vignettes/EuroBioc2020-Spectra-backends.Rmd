---
title: "EuroBioC2020: Seamless Integration of Mass Spectrometry Data from Different Sources with the `Spectra` Package"
author: "Johannes Rainer^[Institute for Biomedicine, Eurac Research, Bolzano, Italy; johannes.rainer@eurac.edu], Michael Witting^[Research Unit Analytical BioGeoChemistry, Helmholtz Zentrum MÃ¼nchen and Chair of Analytical Food Chemistry, TUM School or Life Sciences, Technical University of Munich, Germany], Sebastian Gibb^[Department of Anaesthesiology and Intensive Care, University Medicine Greifswald, Germany], Laurent Gatto^[Computational Biology Unit, de Duve Institute, UCLouvain, Brussels, Belgium]"
output:
  rmarkdown::html_document:
    highlight: pygments
    toc: true
    toc_depth: 3
    fig_width: 5
vignette: >
  %\VignetteIndexEntry{Seamless Integration of Mass Spectrometry Data from Different Sources}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding[utf8]{inputenc}
  %\VignettePackage{SpectraTutorials}
  %\VignetteDepends{Spectra,mzR,RMariaDB,pheatmap,BiocStyle}
bibliography: references.bib
---

```{r style, echo = FALSE, results = 'asis', message = FALSE}
library(BiocStyle)
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

**Last modified:** `r file.info("EuroBioc2020-Spectra-backends.Rmd")$mtime`<br />
**Compiled**: `r date()`

Note: this document is used for the online workshop. A version with more
descriptive text is available
[here](analyzing-MS-data-from-different-sources-with-Spectra.Rmd).


# Introduction

- Describe the concept of *backends* to store/represent mass spectrometry (MS)
  data in the `Spectra` package.
- Use case: match experimental MS2 spectra against *reference* spectra from a
  public spectra database:
    - import MS data from *mzML* files
    - perform some data manipulations on this data
    - match spectra against the [MassBank](https://massbank.eu/MassBank/)
    - match spectra against the [Human Metabolome Database](https://hmdb.ca)
    - export spectra in *MGF* format.


# Installation

The source code of this tutorial is available at
[https://github.com/jorainer/SpectraTutorials](https://github.com/jorainer/SpectraTutorials).
A [docker](https://www.docker.com/) image with all data and necessary packages
is available [here](https://hub.docker.com/r/jorainer/spectra_tutorials).

To run this tutorial locally:

- Get the [docker image](https://hub.docker.com/r/jorainer/spectra_tutorials) of
  this tutorial with `docker pull jorainer/spectra_tutorials:latest`.
- Start docker using
  ```
  docker run \
      -e PASSWORD=bioc \
      -p 8787:8787 \
      jorainer/spectra_tutorials:latest
  ```
- Enter `http://localhost:8787` in a web browser and log in with username
  `rstudio` and password `bioc`.
- Open the R-markdown file
  (*vignettes/analyzing-MS-data-from-different-sources-with-Spectra.Rmd*) in the
  RStudio server version in the web browser and evaluate the R code blocks.
- Optionally, to run also the code to import the MS2 spectra from HMDB the *All
  Spectra Files (XML)* archive from the [hmdb downloads
  page](https://hmdb.ca/downloads) has to be downloaded. The contents of the
  *hmdb_all_spectra.zip* archive should then be unzipped into the folder
  *data/hmdb_all_spectra*.


# LC-MS/MS in a nutshell


- Mass spectrometry (MS) instruments measure mass-to-charge ratios (m/z) of
  ions.
- Most compounds are not charged, they need to be ionized first (with
  e.g. electro spray ionization (ESI).
- MS is usually combined with another separation technique, such as liquid
  chromatography (LC). This adds another dimension: retention time (rt).
- With LC-MS we measure *features* characterized by m/z and retention time - we
  still don't know what molecule was actually measured.

![LC-MS setup](LC-MS-drawing.gif)

- Create in addition fragment (MS/MS) spectra from the ions to get some
  information about their structure.
- Commonly used method: collision induced dissociation (CID). In a collision
  chamber filled with e.g. N2, ions get fragmented, a spectrum of these
  fragments is recorded.
- Matching fragment spectra from an ion against a *reference* helps identifying
  the compound.

![CID-based fragmentation](MSMS.png)


# Analysing MS data with `Spectra`

- The `Spectra` package implements a clear separation of user functionality from
  code to provide, store and read mass spectrometry data.
- This represents an extension to the *in-memory* and *on-disk* data modes
  already in the `r Biocpkg("MSnbase")` [@gattoMSnbaseEfficientElegant2020a].

![Spectra: separation into user functionality and data
representation](Spectra.png)

- Enables analysis of very large MS data sets: backends that import the data
  only on demand.


- Below we import the MS data from mzML files containing MSn data of a mix of 8
  standard compounds.
- MS2 data was generated by data dependent acquisition using two different
  collision energies.
- We use the `MsBackendMzR` backend which supports data import from most common
  *raw* MS file formats:

```{r data-import}
library(Spectra)
fls <- dir(system.file("mzML", package = "SpectraTutorials"),
           full.names = TRUE)
sps_all <- Spectra(fls, backend = MsBackendMzR())
```

- `sps_all` is now a `Spectra` object: `data.frame`-like representation with
  columns being spectra variables and rows individual spectra.
- Spectra variables can be accessed *via* `$` or using the dedicates access
  function (preferred way).
- Use `spectraVariables` to list all available spectra variables:

```{r spectraVariables}
spectraVariables(sps_all)
```

- Access retention times of the first spectra:

```{r rtime}
head(sps_all$rtime)
head(rtime(sps_all))
```

- Our `Spectra` object uses a `MsBackendMzR` backend to provide the data.
- Only general spectra information is kept in memory, MS peak data is retrieved
  on demand from the original data files. This ensures a small memory footprint.

```{r on-disk-size}
print(object.size(sps_all), units = "MB")
```

- `MsBackendDataFrame` backend keeps all data in memory.
- `setBackend` allows to change backends - which does not affect the way we can
  use/work with the data.

```{r change-backend}
sps_all <- setBackend(sps_all, MsBackendDataFrame())
print(object.size(sps_all), units = "MB")
```

- Next we subset our data to MS2 spectra with a precursor ion that matches the
  m/z of the [M+H]+ ion of the metabolite Cystine.

```{r filter-precursor-mz}
mz <- 241.0311

sps <- filterPrecursorMz(sps_all, mz = mz + ppm(c(-mz, mz), 10))
sps
```

- In total `r length(sps)` spectra matched our target precursor m/z.


## Data processing and manipulation

The `plotSpectra` function can be used to visualize spectra. Below we plot the
first of the spectra we selected above.

```{r raw-ms2, fig.width = 7, fig.height = 7}
plotSpectra(sps[1])
```

This raw MS2 spectrum contains many very low abundance peaks, most likely
representing noise. Thus we next filter the spectra removing all peaks with an
intensity smaller than 5% of the maximum intensity of each spectrum (i.e. the
base peak intensity). To this end we define a function that takes intensity
values from each spectrum and returns a logical value whether the peak should be
kept (`TRUE`) or not (`FALSE`). This function is then passed to the
`filterIntensity` function.

```{r filter-intensity}
low_int <- function(x, ...) {
    x > max(x, na.rm = TRUE) * 0.05
}
sps <- filterIntensity(sps, intensity = low_int)
```

In addition we *normalize* each spectrum replacing the absolute intensity values
with values relative to the spectrum's maximum intensity (which is set to
100). For this operation we also define a function which takes a *peak matrix*
as input and returns a matrix with the same dimensions. The peak matrix is the
two-column matrix with m/z (first column) and intensity values (second column)
of each peak of a spectrum. This function is then passed with parameter `FUN` to
the `addProcessing` function which allows to apply any user-defined function to
the peak matrix of each spectrum in a `Spectra` object.

```{r normalize}
norm_int <- function(x, ...) {
    maxint <- max(x[, "intensity"], na.rm = TRUE)
    x[, "intensity"] <- 100 * x[, "intensity"] / maxint
    x
}
sps <- addProcessing(sps, norm_int)
```

To show the effect of the normalization we extract the intensities of the first
spectrum:

```{r}
intensity(sps)[[1]]
```

The intensity values are now all between 0 and 100. Note that all these data
manipulations (intensity filtering and normalization) did **not** change the
original m/z and intensity values. Data manipulation operations are cached by
default in the *lazy processing queue* of the `Spectra` object and applied
to the data *on-the-fly* each time m/z or intensity values are accessed. This
ensures that the same data manipulations can be used for any type of backend,
even if the data resource is *read-only* (e.g. if the data is retrieved on the
fly from mzML files).

This mechanism enables us also to *undo* cached data manipulations with the
`reset` function:

```{r reset}
sps_orig <- reset(sps)
head(intensity(sps_orig)[[1]])
```


## Spectrum data comparison

We next perform a pairwise comparison of the spectra using the dot product as
similarity measure. Prior to the actual similarity calculation, the peaks of the
individual spectra have to be matched against each other (i.e. it has to be
determined which peak from one spectrum correspond to which from the other
spectrum based on their mass-to-charge ratios). We specify `ppm = 20` so that
peaks with a difference in m/z smaller than 20ppm will be considered matching.

```{r compare-spectra-self}
cormat <- compareSpectra(sps, ppm = 20)
```

The pairwise spectra similarities are represented with the heatmap below.

```{r ms2-heatmap, fig.width = 7, fig.height = 7}
library(pheatmap)
hm <- pheatmap(cormat, cutree_rows = 3)
```

The 11 spectra group into 3 clusters, which are in fact related to the collision
energy used for the fragmentation (see below; the collision energy is encoded in
the file name as CE20 and CE30). We subsequently reduce our dataset to the
cluster with the spectra generated with a collision energy of 20eV.

```{r}
split(basename(dataOrigin(sps)), cutree(hm$tree_row, 3))
sps_ce20 <- split(sps, cutree(hm$tree_row, 3))[[1L]]
```

Although the precursor m/z of our spectra matches the m/z of Cystine, we can
still not exclude that they might represent fragmentations of ions from
a different compound (i.e. that would have the same precursor m/z).

Matching experimental spectra against a public spectral library can be used as a
first step in the identification process. Several (public) spectral libraries
for small molecules are available, such as
[MassBank](https://massbank.eu/MassBank/),
[MoNa](https://mona.fiehnlab.ucdavis.edu/) (MassBank of North America), the
Human Metabolom Database [HMDB](https://hmdb.ca/) or
[GNPS](https://gnps.ucsd.edu/ProteoSAFe/static/gnps-splash.jsp). For some of
these databases `MsBackend` interfaces are already implemented allowing
inclusion of their data directly into R-based analysis workflows. Access to
MassBank data is for example possible with the
[MsBackendMassbank](https://github.com/michaelwitting/MsBackendMassbank)
package. This package provides the `MsBackendMassbank` for import/export
of [MassBank files](https://github.com/MassBank/MassBank-data) as well as the
`MsBackendMassbankSql` backend that directly interfaces the MassBank MySQL
database.

Below we load the `MsBackendMassbank` package and connect to a local
installation of the MassBank MySQL database (release *2020.11* which is provided
within the docker image of this tutorial).

```{r massbank-library}
library(RMariaDB)
library(MsBackendMassbank)

con <- dbConnect(MariaDB(), user = "massbank", dbname = "MassBank",
                 host = "localhost")
```

We can now initialize a `Spectra` object with a `MsBackendMassbankSql` backend
to access all the data in MassBank.

```{r massbank}
mbank <- Spectra(con, source = MsBackendMassbankSql())
mbank
```

The `Spectra` object `mbank` *represents* now the MS data from the
MassBank database with in total `length(mbank)` spectra. In fact, the `mbank`
object does only contain the primary keys of the spectra but no MS data. Hence,
it's size in memory is only relatively small:

```{r massbank-size}
print(object.size(mbank), units = "MB")
```

Any operation on this `Spectra` object will load the requested data from the
database on-the-fly.

We can now compare our experimental spectra against the *reference* spectra from
MassBank. Because loading data from the database takes some time, we first
screen for spectra that have a peak matching the precursor m/z (even this
operation takes ~ 30 seconds to finish).

```{r massbank-contains-mz}
has_mz <- containsMz(mbank, mz = mz, ppm = 20)
```

Note that, to improve performance, we could also load all the spectra data into
memory by simply changing the backend with `setBackend` to a
`MsBackendDataFrame` (as we did with the experimental spectra data above).

In total `r sum(has_mz)` spectra contain a peak with the required m/z and we can
proceed to calculate spectral similarities between our experimental spectra and
this subset from MassBank.

```{r massbank-compare-subset}
mbank_with_mz <- mbank[has_mz]
res <- compareSpectra(sps_ce20, mbank_with_mz, ppm = 20)
```

The highest similarity between our spectra and the spectra from MassBank is
`r max(res)`. Below we indentify the best matching spectrum and access its
intensity values.

```{r massbank-intensity}
idx <- which(res == max(res), arr.ind = TRUE)
intensity(mbank_with_mz[idx[2]])
```

Absolute intensities are reported for the MassBank spectrum, but for better
visualizations we would like to *normalize* them the same way we did with our
experimental spectra. As a side note it should also be mentioned that the used
dot product function for spectra similarity is independent of absolute intensity
values, thus, it did not matter if we performed the spectra comparisons on
absolute or relative intensities.

The above described *lazy processing queue* of `Spectra` objects allows us to
perform data manipulations on the MassBank data without actually modifying the
original data. We thus normalize the MassBank spectra with the same function we
used for the experimental spectra.

```{r massbank-normalize}
mbank_with_mz <- addProcessing(mbank_with_mz, norm_int)
```

Below we can then compare the two best matching spectra with a *mirror plot*, in
the upper panel showing our experimental spectrum and in the lower panel the
best matching MS2 spectrum from MassBank.

```{r massbank-mirror-plot, fig.width = 7, fig.height = 7}
## Specifying a function to draw peak labels
label_fun <- function(x) {
    format(unlist(mz(x)), digits = 4)
}
plotSpectraMirror(sps_ce20[idx[1]], mbank_with_mz[idx[2]], tolerance = 0.2,
                  labels = label_fun, labelPos = 2, labelOffset = 0.2,
                  labelSrt = -30)
grid()
```

Our experimental spectrum nicely matches the *reference* MS2 in MassBank. We
next want to know which compound this spectrum actually represents. `Spectra`
objects can have arbitrarily many additional annotation fields (so called
*spectra variables*) and we can use the `spectraVariables` function to list all
of them which are available in a specific `Spectra` object.

```{r massbank-spectra-variables}
spectraVariables(mbank_with_mz)
```

While we can get a large number of information for each spectrum, there is only
limited information on the actual compound available (i.e. only a *compound_id*
field available, but for example no compound name).

The `MsBackendMassbank` package defines however an additional function
`compounds` which takes a `Spectra` object (that uses a `MsBackendMassbankSql`
backend) and retrieves the compound information for the spectra from the
MassBank database. Thus, below we first subset our `Spectra` object to the
MassBank spectrum that best matches our experimental spectrum and call the
`compounds` function on this spectrum to get all of its compound annotations
from the database.

```{r massbank-one-spectrum}
mbank_best_match <- mbank_with_mz[idx[2]]
mbank_cmpd <- compounds(mbank_best_match)
mbank_cmpd
```

Thus, the best matching spectrum is in fact a MS2 spectrum of Cystine. Below we
add the name and the chemical formula for the best matching spectrum to our
experimental spectra. We also set the collision energy for these spectra to 20eV
and assign the ion/adduct of Cystine from which the reference spectrum was
created.

```{r}
sps_ce20$hmdb_id <- mbank_cmpd$name
sps_ce20$formula <- mbank_cmpd$formula
sps_ce20$adduct <- mbank_best_match$adduct
sps_ce20$collisionEnergy <- 20
```


## Data export

At last we want to export our spectra to a file in MGF format. For this we use
the [MsBackendMgf](https://github.com/RforMassSpectrometry/MsBackendMgf) R
package which provides the `MsBackendMgf` backend that adds support for MGF file
import/export to `Spectra` objects.

Data from `Spectra` objects can generally be exported with the `export`
function. The format in which the data is exported depends on the specified
`MsBackend` class. By using an instance of `MsBackendMgf` we can write below the
data to a file in MGF format.

```{r export}
library(MsBackendMgf)
export(sps_ce20, backend = MsBackendMgf(), file = "Cystine_ce20.mgf")
```


## Matching against HMDB

In addition to the `MsBackendMassbank`, which provides access to MassBank data,
there is also the
[`MsBackendHmdb`](https://github.com/RforMassSpectrometry/MsBackendHmdb) package
supporting spectral data from the public Human Metabolome Database (HMDB). This
package does however not yet provide direct access to the HMDB database but,
through the `MsBackendHmdbXml` backend, allows to import MS2 spectra files in
HMDB format. These are provided by HMDB as individual xml files in a custom file
format which are bundled (and can hence be downloaded) in a single archive.

To reproduce the following code it is expected (as detailed in the Installation
section) that all xml files from HMDB are available in a folder
*data/hmdb_all_spectra*. Below we identify all xml files containing the key word
`"ms_ms"` in their file name and load them into a `Spectra` object using the
`MsBackendHmdbXml` backend. Note that this import operation from the ~ 500,000
individual xml files takes up to ~ 2 hours to finish.

```{r hmdb-import, eval = FALSE}
library(MsBackendHmdb)
fls <- dir("data/hmdb_all_spectra/", full.names = TRUE, pattern = "ms_ms")
hmdb <- Spectra(fls, source = MsBackendHmdbXml(), nonStop = TRUE)
```

```{r hmdb-import-save, eval = FALSE, echo = FALSE}
## Eventually save for faster re-use
save(hmdb, file = "data/hmdb.RData", compress = "xz")
```

```{r hmdb-load, echo = FALSE}
## Load the pre-generated Spectra object with spectra from HMDB.
library(MsBackendHmdb)
data("hmdb", package = "SpectraTutorials")
```

With this we have now a `Spectra` object containing all MS2 spectra from
HMDB. Note that with the `MsBackendHmdbXml` all spectra data is kept in memory.

```{r}
hmdb
```

Also here, to avoid comparing our experimental spectra against all these
~500,000 spectra, we first determine with the `containsMz` function which of the
HMDB spectra contain a peak matching the m/z of our ion of interest. We have to
use a rather large `tolerance` value (which defines the maximal acceptable
absolute difference in m/z values) since some of the experimental spectra in
HMDB seem to be recorded by not well calibrated instruments.

```{r has-mz}
has_mz <- containsMz(hmdb, mz = mz, tolerance = 0.2)
```

In total `r sum(has_mz)` spectra contain a peak with the required m/z (+/- 0.2
Dalton) and we can proceed to calculate spectral similarities between our
experimental spectra and this subset from HMDB.

```{r compare-subset}
hmdb_with_mz <- hmdb[has_mz]
res <- compareSpectra(sps_ce20, hmdb_with_mz, tolerance = 0.2)
```

The highest similarity between our spectra and the spectra from HMDB is `r
max(res)`. Below we compare the two best matching spectra with a *mirror plot*,
in the upper panel showing our experimental spectrum and in the lower panel the
best matching MS2 spectrum from HMDB.

```{r mirror-plot, fig.width = 7, fig.height = 7}
idx <- which(res == max(res), arr.ind = TRUE)
## Specifying a function to draw peak labels
label_fun <- function(x) {
    format(unlist(mz(x)), digits = 4)
}
plotSpectraMirror(sps_ce20[idx[1]], hmdb_with_mz[idx[2]], tolerance = 0.2,
                  labels = label_fun, labelPos = 2, labelOffset = 0.2,
                  labelSrt = -30)
grid()
```

Our experimental spectrum seems to nicely match the *reference* MS2 in
HMDB. Below we extract the compound identifier from the best matching HMDB
spectrum (stored in a spectra variable called `"compound_id"`)

```{r}
hmdb_with_mz[idx[2]]$compound_id
```

In fact, the matching spectrum from HMDB is an experimental spectrum for
[L-Cystine](https://hmdb.ca/metabolites/HMDB0000192).


# Summary

With the simple use case of matching experimental MS2 spectra against a public
database we illustrated in this short tutorial the flexibility and expandability
of the `Spectra` package that enables the seamless integration of mass
spectrometry data from different sources. This was only possible with a clear
separation of the user functionality (`Spectra` object) from the representation
of the data (`MsBackend` object). Backends such as the
[`MsBackendMgf`](https://github.com/RforMassSpectrometry/MsBackendMgf), the
[`MsBackendMassbank`](https://github.com/michealwitting/MsBackendMassbank) or
the [`MsBackendHmdbXml`](https://github.com/RforMassSpectrometry/MsBackendHmdb)
can provide support for additional data formats or data sources, while others,
due to their much lower memory footprint (`MsBackendMzR`, `MsBackendHdf5Peaks`),
enable the analysis of also very large data sets. Most importantly however,
these backends are interchangeable and do not affect the way users can handle
and analyze MS data with the `Spectra` package.


# References
